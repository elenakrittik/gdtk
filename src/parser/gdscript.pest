//! GDScript Parsing Expression Grammar

//! Always document every single line you write,
//! **verboseness is intentional**.
//! Formatting is appreciated, but optional.

// WHITESPACE defines rule used for determining whether
// an unknown (i.e. errorneous) character can be silenced
// in certain cases.
WHITESPACE = _{ // silent rule defined as
	" "         //  space character ( )
}

// string defines a simple string rule
// matches: "Hello!"
// matches "Backslash: \\"
// matches: "Forward slash: \/"
// matches: "Double quote: \""
string = ${ // compound atomic rule defined as
	"\""    //  double quote (")
	~ inner //  immediately followed by inner
	~ "\""  //  immediately followed by double quote
}

// inner defines inner content of a string
// matches: bajcudbn_&-@(7_6/)!*`~
inner = @{ // atomic rule defined as
	char*  //  zero or more chars
}

// char defines characters allowed in strings
char = {       // rule defined as
    !(         //   neither
		"\""   //    double quote (")
		| "\\" //    nor backslash (\)
	)
	~ ANY      //   followed by any character
	           //  or
	| "\\"     //   backslash (\)
	~ (        //   followed by
		"\""   //    double quote (")
		| "\\" //    or backslash (\)
		| "/"  //    or forward slash (/)
	)
}

// identifier defines a valid name for function,
// variable, etc.
identifier = {
	ASCII_ALPHA
	~ ASCII_ALPHANUMERIC*
}

remainder_of_line = _{
	(!"\n" ~ ANY)+
}

comment = _{
    "#"
	~ " "*
	~ remainder_of_line?
}

annotation_base = _{
	"@"
	~ identifier
}

basic_annotation = {
	annotation_base
	~ (" " ~ var)?
}

annotation = {
	annotation_base
	~ "("
	~ (string ~ ","?)*
	~ ")"
	~ (" " ~ var)?
}

number = {
	ASCII_DIGIT+
}

value = _{
	string
	| number
	| identifier
}

typehint = {
	(":" ~ identifier)
}

var = {
	"var"
	~ identifier
	~ typehint?
	~ "="
	~ value
}

statement = _{
	comment
	| annotation
	| basic_annotation
	| var
	| value
}

file = _{           // silent rule defined as
	SOI             //  start-of-input
	~ "\n"*         //  followed by zero or more newlines
	~ (             //  followed by a group defined as
		statement*  //   zero or more statements
		~ "\n"+     //   followed by one or more newlines
	)*              //  repeated zero or more times
	~ statement?    //  followed by an optional statement
	~ EOI           //  followed by end-of-input
}
