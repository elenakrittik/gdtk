//! GDScript Parsing Expression Grammar

//! Always document every single line you write,
//! **verboseness is intentional**.
//! Formatting is appreciated, but optional.

// WHITESPACE defines rule used for determining whether
// an unknown (i.e. errorneous) character can be silenced
// in certain cases.
WHITESPACE = _{ // silent rule defined as
	" "         //  space character ( )
}

COMMENT = _{
	comment
}

// string defines a simple string rule
// matches: "Hello!"
// matches "Backslash: \\"
// matches: "Forward slash: \/"
// matches: "Double quote: \""
string = ${ // compound atomic rule defined as
	"\""    //  double quote (")
	~ inner //  immediately followed by inner
	~ "\""  //  immediately followed by double quote
}

// inner defines inner content of a string
// matches: bajcudbn_&-@(7_6/)!*`~
inner = @{ // atomic rule defined as
	char*  //  zero or more chars
}

// char defines characters allowed in strings
char = {       // rule defined as
    !(         //   neither
		"\""   //    double quote (")
		| "\\" //    nor backslash (\)
	)
	~ ANY      //   followed by any character
	           //  or
	| "\\"     //   backslash (\)
	~ (        //   followed by
		"\""   //    double quote (")
		| "\\" //    or backslash (\)
		| "/"  //    or forward slash (/)
	)
}

// identifier defines a valid name for function,
// variable, etc.
identifier = @{
	(ASCII_ALPHA | "_")
	~ (ASCII_ALPHANUMERIC | "_")*
}

remainder_of_line = _{
	(!"\n" ~ ANY)+
}

comment = _{
    "#"
	~ " "*
	~ remainder_of_line?
}

annotation_base = ${
	"@"
	~ identifier
}

basic_annotation = {
	annotation_base
	~ (" " ~ var)?
}

annotation = {
	annotation_base
	~ "("
	~ (string ~ ","?)*
	~ ")"
	~ (" " ~ var)?
}

number = {
	"-"?
	~ ASCII_DIGIT+
}

array = {
	"["
	~ (value ~ ","?)*
	~ "]"
}

key_value = {
	value
	~ ":"
	~ value
}

dict = {
	"{"
	~ (key_value ~ ","?)*
	~ "}"
}

lua_key_value = {
	identifier
	~ "="
	~ value
}

lua_dict = {
	"{"
	~ (lua_key_value ~ ","?)*
	~ "}"
}

value = _{
	string
	| number
	| array
	| dict
	| lua_dict
	| call
}

typehint = {
	(":" ~ identifier)
}

var = {
	"var"
	~ identifier
	~ typehint?
	~ ("=" ~ value)?
}

inferred_var = {
	"var"
	~ identifier
	~ ":="
	~ value
}

param = {
	identifier
	~ typehint?
}

func = {
	"func"
	~ identifier
	~ "("
	~ (param ~ ","?)*
	~ "):"
}

const = {
	"const"
	~ identifier
	~ "="
	~ value
}

class_name = {
	"class_name"
	~ identifier
}

extends = {
	"extends"
	~ identifier
}

enum_key_value = {
	identifier
	~ ("=" ~ number)?
}

enum = {
	"enum"
	~ identifier?
	~ "{"
	~ (enum_key_value ~ ","?)*
	~ "}"
}

call = {
	identifier
	~ "("
	~ (value ~ ","?)*
	~ ")"
}

statement = _{
	annotation
	| basic_annotation
	| inferred_var
	| var
	| class_name
	| extends
	| const
	| enum
	| call
	| func
	| value
	| identifier
}

code = _{
	"\n"*
     ~ (
         statement*
         ~ "\n"+
	)*
     ~ statement?
}

file = _{
	SOI
	~ code
	~ EOI
}
